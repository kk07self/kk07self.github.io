<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>KK</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="KK">
<meta property="og:url" content="http://ikirk.cn/page/2/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KK">
  
    <link rel="alternate" href="/atom.xml" title="KK" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">KK</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://ikirk.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-11-RunLoop" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/11-RunLoop/" class="article-date">
  <time datetime="2018-11-15T01:41:56.682Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>运行循环，在程序运行过程中循环做些事情</p>
<ul>
<li>作用<ul>
<li>保持程序的持续运行</li>
<li>处理APP中的各种事务（比如触摸事件、定时器）</li>
<li>节省CPU，提高性能：该做事时做事，该休息时休息</li>
</ul>
</li>
</ul>
<h4 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h4><ul>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li>
<li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li>
<li>RunLoop会在线程结束时销毁</li>
<li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
<h4 id="RunLoop对象"><a href="#RunLoop对象" class="headerlink" title="RunLoop对象"></a>RunLoop对象</h4><p>NSRunLoop是对CFRunLoopRef的面相对象的封装</p>
<ul>
<li><p><strong>获取对象</strong></p>
<ul>
<li><p>Foundation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</span><br><span class="line">[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>Core Foundation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</span><br><span class="line">CFRunLoopGetMain(); // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Runloop相关的类</strong></p>
<p>Core Foundation中有关于RunLoop有5个类</p>
<ul>
<li>CFRunLoopRef：RunLoop类</li>
<li>CFRunLoopModeRef: RunLoop对应的模式类</li>
<li>CFRunLoopSourceRef：资源类</li>
<li>CFRunLoopTimerRef：事件类</li>
<li>CFRunLoopObserverRef：观察者类</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> *<span class="title">CFRunLoopRef</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _curentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    CFStringRef _name;<span class="comment">// 名称</span></span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFRunLoopModeRef _observers;</span><br><span class="line">    CFRunLoopModeRef _times;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>CFRunLoopModeRef</strong></p>
<ul>
<li><p>CFRunLoopModeRef代表RunLoop的运行模式；</p>
</li>
<li><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer；</p>
</li>
<li><p>RunLoop启动时只能选择其中一个Mode，作为currentMode；</p>
</li>
<li><p>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入；</p>
<p>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响；</p>
<p>source1是捕捉事件的，source0是用来处理事件的</p>
</li>
<li><p>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</p>
</li>
<li><p>常见的mode模式有两种：</p>
<ul>
<li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>kCFRunLoopCommonModes：不是一种单独的模式，只是上面两个状态的集合</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CFRunLoopObserverRef</strong></p>
<p>观察者主要是监听runloop的活跃状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), 			// 即将进入runloop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),	// 即将处理timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),	// 即将处理sources</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),	// 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),	// 即将从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),			// 即将推出runloop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听不同的模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">observeRunLoopActicities</span><span class="params">(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            NSLog(@<span class="string">"kCFRunLoopEntry"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            NSLog(@<span class="string">"kCFRunLoopBeforeTimers"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            NSLog(@<span class="string">"kCFRunLoopBeforeSources"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            NSLog(@<span class="string">"kCFRunLoopBeforeWaiting"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            NSLog(@<span class="string">"kCFRunLoopAfterWaiting"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            NSLog(@<span class="string">"kCFRunLoopExit"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="Runloop运行逻辑"><a href="#Runloop运行逻辑" class="headerlink" title="Runloop运行逻辑"></a>Runloop运行逻辑</h4><ul>
<li>01、通知Observers：即将进入loop</li>
<li>02、通知Observers：即将处理Timer，然后处理Timer</li>
<li>03、通知Observers：即将处理Sources，然后处理Sources</li>
<li>04、处理Blocks</li>
<li>05、处理Sources0（可能会再次处理blocks）</li>
<li>06、如果存在source1(有事件捕捉)则调到第08步</li>
<li>07、通知Observers：开始休眠（等待消息唤醒）</li>
<li>08、通知Observers：结束休眠（被某个消息唤醒）<ul>
<li>01&gt;处理timer</li>
<li>02&gt;处理GCD</li>
<li>03&gt;处理Source1</li>
</ul>
</li>
<li>09、处理blocks</li>
<li>10、根据前面执行结果，决定如何操作<ul>
<li>01&gt;回到第02步，循环操作</li>
<li>02&gt;退出Loop</li>
</ul>
</li>
<li>11、通知Observers：退出loop</li>
</ul>
<ul>
<li><p>休眠的实现原理：</p>
<p>用户态中的<code>mach_msg()</code>让其进入到内核态进行休眠</p>
<ul>
<li>没有消息就让线程休眠</li>
<li>有消息就进行唤醒，然后到用户态处理消息</li>
</ul>
</li>
</ul>
<h4 id="RunLoop的应用"><a href="#RunLoop的应用" class="headerlink" title="RunLoop的应用"></a>RunLoop的应用</h4><ul>
<li>控制线程生命周期（线程保活）</li>
<li>解决NSTimer在滑动时停止工作的问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/15/11-RunLoop/" data-id="cjpnsun95000acbhb276do0cj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-09-runtimeAPI" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/14/09-runtimeAPI/" class="article-date">
  <time datetime="2018-11-14T09:04:26.990Z" itemprop="datePublished">2018-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="runtime-API"><a href="#runtime-API" class="headerlink" title="runtime API"></a>runtime API</h1><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个类（要在类注册之前添加成员变量）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取isa指向的Class</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置isa指向的Class</span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个OC对象是否为Class</span></span><br><span class="line"><span class="function">BOOL <span class="title">object_isClass</span><span class="params">(id obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个Class是否为元类</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个实例变量信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝实例变量列表（最后需要调用free释放）</span></span><br><span class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置和获取成员变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加成员变量（已经注册的类是不能动态添加成员变量的）</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">size_t</span> size, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> * types)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar v)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量的数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="comment">// 取出i位置的成员变量</span></span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    NSLog(@<span class="string">"%s %s"</span>, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(ivars);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量信息</span></span><br><span class="line">Ivar ageIvar = class_getInstanceVariable([MJPerson class], <span class="string">"_age"</span>);</span><br><span class="line">NSLog(@<span class="string">"%s %s"</span>, ivar_getName(ageIvar), ivar_getTypeEncoding(ageIvar));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置和获取成员变量的值</span></span><br><span class="line">Ivar nameIvar = class_getInstanceVariable([MJPerson class], <span class="string">"_name"</span>);</span><br><span class="line"></span><br><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">object_setIvar(person, nameIvar, @<span class="string">"123"</span>);</span><br><span class="line">object_setIvar(person, ageIvar, (__bridge id)(<span class="keyword">void</span> *)<span class="number">10</span>);</span><br><span class="line">NSLog(@<span class="string">"%@ %d"</span>, person.name, person.age);</span><br></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝属性列表（最后需要调用free释放）</span></span><br><span class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加属性</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态替换属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的一些信息</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得一个实例方法、类方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法实现相关操作</span></span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"><span class="function">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法列表（最后需要调用free释放）</span></span><br><span class="line"><span class="function">Method *<span class="title">class_copyMethodList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加方法</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态替换方法</span></span><br><span class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的相关信息（带有copy的需要调用free去释放）</span></span><br><span class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="function">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">method_copyReturnType</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择器相关</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span>;</span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用block作为方法实现</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例</span></span><br><span class="line">MJPerson *person = [[MJPerson alloc] init];   </span><br><span class="line">Method runMethod = class_getInstanceMethod([MJPerson class], @selector(run));</span><br><span class="line">Method testMethod = class_getInstanceMethod([MJPerson class], @selector(test));</span><br><span class="line">method_exchangeImplementations(runMethod, testMethod);</span><br><span class="line">[person run];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"UIControl+Extension.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">UIControl</span> <span class="params">(Extension)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// hook：钩子函数</span></span><br><span class="line">    Method method1 = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(self, @selector(kk_sendAction:to:forEvent:));</span><br><span class="line">    method_exchangeImplementations(method1, method2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)kk_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@<span class="string">"%@-%@-%@"</span>, self, target, NSStringFromSelector(action));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用系统原来的实现</span></span><br><span class="line">    [self kk_sendAction:action to:target forEvent:event];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [target performSelector:action];</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    if ([self isKindOfClass:[UIButton class]]) &#123;</span></span><br><span class="line"><span class="comment">//        // 拦截了所有按钮的事件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止数组空元素及数组越界</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSMutableArray+Extension.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">NSMutableArray</span> <span class="params">(Extension)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型</span></span><br><span class="line">        Class cls = NSClassFromString(@<span class="string">"__NSArrayM"</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, @selector(insertObject:atIndex:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, @selector(kk_insertObject:atIndex:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)kk_insertObject:(id)anObject atIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (anObject == nil) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [self kk_insertObject:anObject atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止字典空key</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSMutableDictionary+Extension.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">NSMutableDictionary</span> <span class="params">(Extension)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class cls = NSClassFromString(@<span class="string">"__NSDictionaryM"</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, @selector(setObject:forKeyedSubscript:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, @selector(kk_setObject:forKeyedSubscript:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">        </span><br><span class="line">        Class cls2 = NSClassFromString(@<span class="string">"__NSDictionaryI"</span>);</span><br><span class="line">        Method method3 = class_getInstanceMethod(cls2, @selector(objectForKeyedSubscript:));</span><br><span class="line">        Method method4 = class_getInstanceMethod(cls2, @selector(kk_objectForKeyedSubscript:));</span><br><span class="line">        method_exchangeImplementations(method3, method4);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)kk_setObject:(id)obj forKeyedSubscript:(id&lt;NSCopying&gt;)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [self kk_setObject:obj forKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)kk_objectForKeyedSubscript:(id)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> nil;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [self kk_objectForKeyedSubscript:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+Extension.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">NSArray</span> <span class="params">(Extension)</span></span></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 类簇：NSString、NSArray、NSDictionary，真实类型是其他类型</span></span><br><span class="line">        Class cls = NSClassFromString(@<span class="string">"__NSArrayI"</span>);</span><br><span class="line">        Method method1 = class_getInstanceMethod(cls, @selector(objectAtIndex:));</span><br><span class="line">        Method method2 = class_getInstanceMethod(cls, @selector(kk_objectAtIndex:));</span><br><span class="line">        method_exchangeImplementations(method1, method2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)kk_objectAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= self.count) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [self kk_objectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/14/09-runtimeAPI/" data-id="cjpnsun920008cbhb97sn5zeo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-10-关键字" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/14/10-关键字/" class="article-date">
  <time datetime="2018-11-14T08:41:12.796Z" itemprop="datePublished">2018-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h4 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h4><p>@dynamic 告诉编译器不用生成getter和setter方法的实现，等运行时再添加方法实现</p>
<p>@synthesize 告诉编译器生成getter和setter方法的实现</p>
<h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><ul>
<li><p><strong>final</strong></p>
<p>final关键字在大多数的编程语言中都存在，表示不允许对其修饰的内容进行继承或者重新操作。</p>
<p>Swift中，final关键字可以在class、func和var前修饰。</p>
</li>
<li><p><strong>typealias</strong></p>
<p>typealias 是用来为已经存在的类型重新定义名字的，通过命名，可以使代码变得更加清晰。</p>
</li>
<li><p><strong>associatedtype</strong></p>
<p>关联类型，定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/14/10-关键字/" data-id="cjpnsun940009cbhbmyneywbo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-07-Class底层结构" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/09/07-Class底层结构/" class="article-date">
  <time datetime="2018-11-09T09:15:20.015Z" itemprop="datePublished">2018-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Class底层结构"><a href="#Class底层结构" class="headerlink" title="Class底层结构"></a>Class底层结构</h1><h4 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的结构体信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa; <span class="comment">// 内部信息参考下面的**isa**</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache; <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class_data_bits_t bits 经过位运算&amp;FAST_DATA_MASK可获得以下数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> versions;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro; 		<span class="comment">// 类的原始信息</span></span><br><span class="line">    <span class="keyword">methon_list_t</span> *methods; 	<span class="comment">//方法列表，二维数组</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *properties;<span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">protocol_list_t</span> *protocols; <span class="comment">//属性列表</span></span><br><span class="line">    Class fiestSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的原始信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize; <span class="comment">// instance对象占用多少存储空间</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name; <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> *ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *wearIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name; <span class="comment">// 函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 编码(返回值、参数类型)</span></span><br><span class="line">    IMP imp; <span class="comment">// 指向函数的指针(函数地址)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP) (id _Nonnull, SEL _Nonnull, ...);</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</li>
<li>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</li>
<li>method_t是对方法\函数的封装（在methods中）<ul>
<li>IMP代表函数的具体实现</li>
<li>SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似<ul>
<li>可以通过@selector()和sel_registerName()获得</li>
<li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
</li>
<li>types包含了函数返回值、参数编码的字符串</li>
</ul>
</li>
</ul>
<h4 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h4><p>Class内部结构中有个方法缓存（cache_t），用<strong>散列表（哈希表）</strong>来缓存曾经调用过的方法，可以提高方法的查找速度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">// 散列表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask; <span class="comment">// 散列表长度-1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key; <span class="comment">// SEL作为key，在查找时，也就是拿SEL来进行查找</span></span><br><span class="line">    IMP _imp; <span class="comment">// 函数的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>散列表查找说明：</strong></p>
<ul>
<li><p>拿空间换时间</p>
</li>
<li><p>散列表中的每个元素都有一个key和要查询的值value</p>
</li>
<li>散列表存储：<ul>
<li>先开辟一定大小的存储空间给散列表，如一开始给开辟4个单元的大小，设定需要与之计算的mask（一般是散列表长度-1，因为列表重0开始计算，3）</li>
<li>存储方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  - 如果根据```index```找到的位置不为空，取出对应位置的值，比较两个值的key是否相同，如果相同就不在进行缓存，如果不相同然后将```index```加1进行下标下移，直到找到空位子为止</span><br><span class="line">  - 如果缓存的数量即将等于或大于散列表的长度，会将散列表的历史元素清除，然后再将散列值的大小扩大至两倍</span><br><span class="line">- 散列表取值：</span><br><span class="line">  - 根据元素特定的值与散列表的mask值进行计算，得出```index```下标值</span><br><span class="line">  - 根据下标值找到对应位置的元素，比较元素中的key值，如果key值相同，则取出里面的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### isa</span><br><span class="line"></span><br><span class="line">每一个实例对象或者类对象的底层都有isa指针，在arm64之前，isa只是一个普通的指针，指着它的类或者元类；在arm64之后，对isa进行了优化，变成了一个共用体（union）结构，并使用位域来存储更多的信息</span><br><span class="line"></span><br><span class="line">arm64之后，isa是一个共用体了</span><br><span class="line"></span><br><span class="line">```objective-c</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    Class cls; // 存储着类的地址</span><br><span class="line">    unitptr_t bits; // 利用位域存储更多的信息</span><br><span class="line">    struct &#123;</span><br><span class="line">        unitptr_t nonpointer			: 1; // 0代表普通指针，存储着class或meta-class,1代码优化过的，使用位域存储更多的信息</span><br><span class="line">        unitptr_t has_assoc				: 1; // 是否有设置关联对象，如果没有，释放时会更快</span><br><span class="line">        unitptr_t has_cxx_dtor			: 1; // 是否有c++的析构函数</span><br><span class="line">        unitptr_t shiftcls				: 3; // 存储着Class、Meta-Class对象的内存地址信息</span><br><span class="line">        unitptr_t magic					: 6; // 用于在调试时分辨对象是否未完成初始化</span><br><span class="line">        unitptr_t weakly_referenced		: 1; // 是否有被弱引用指向过，如果没有，释放时会更快</span><br><span class="line">        unitptr_t deallocating			: 1; // 对象是否正在释放</span><br><span class="line">        unitptr_t has_sidetable_rc		: 1; // 引用计数器是否过大无法存储在isa中,如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span><br><span class="line">        unitpyr_t extra_rc				: 1; // 里面存储的值是引用计数器减1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/09/07-Class底层结构/" data-id="cjpnsun910006cbhbvkqmmo61" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-08-objc_msgSend" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/09/08-objc_msgSend/" class="article-date">
  <time datetime="2018-11-09T03:29:24.173Z" itemprop="datePublished">2018-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="objc-msgSend-消息机制"><a href="#objc-msgSend-消息机制" class="headerlink" title="objc_msgSend-消息机制"></a>objc_msgSend-消息机制</h1><p>OC中方法的调用，其实都是转为objc_msgSend()函数的调用</p>
<p>Objc_msgSend()函数的执行分为三个阶段</p>
<ul>
<li>消息发送阶段</li>
<li>动态方法解析阶段</li>
<li>消息转发阶段</li>
</ul>
<h4 id="流程1：消息发送阶段"><a href="#流程1：消息发送阶段" class="headerlink" title="流程1：消息发送阶段"></a>流程1：消息发送阶段</h4><ul>
<li>消息接收者receiver是否为nil，如果receiver为nil直接退出</li>
<li>从receiver的Class的cache中查找方法，找到了就调用方法查找结束</li>
<li>从receiver的Class的class_rw_t中查找方法，找到了就调用方法并将其缓存在Class的cache_t中，结束查找</li>
<li>判断上层是否有superClass，如果有则继续以下查找，往复，如果没有就进行到下一阶段（动态方法解析）</li>
<li>从receiver的superClass得cache中查找方法，找到了就调用方法查找结束</li>
<li>从receiver的superClass的class_rw_t方法列表中查找方法，找到了就调用方法并将其缓存在Class的cache_t中，结束查找</li>
</ul>
<h4 id="流程2：动态方法解析"><a href="#流程2：动态方法解析" class="headerlink" title="流程2：动态方法解析"></a>流程2：动态方法解析</h4><ul>
<li>是否曾经有动态解析，如果有，则进入到下一阶段（消息转发阶段）</li>
<li>如果没有，调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- 将动态解析的方法放到class_method_t中，并标记为已经动态解析过了，然后走流程1消息发送阶段</span><br><span class="line"></span><br><span class="line">开发者可以实现以下方法，来动态添加方法实现</span><br><span class="line"></span><br><span class="line">- +resolveInstanceMethod:</span><br><span class="line"></span><br><span class="line">- +resolveClassMethod:</span><br><span class="line"></span><br><span class="line">动态解析过后，会重新走“消息发送”的流程，“从receiverClass的cache中查找方法”这一步开始执行</span><br><span class="line"></span><br><span class="line">**动态添加方法**</span><br><span class="line"></span><br><span class="line">```objective-c</span><br><span class="line">void c_other(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;c_other - %@ - %@&quot;, self, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">        // 第一个参数是object_getClass(self)</span><br><span class="line">        class_addMethod(object_getClass(self), sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">        // 动态添加test方法的实现</span><br><span class="line">        class_addMethod(self, sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class="line"></span><br><span class="line">        // 返回YES代表有动态添加方法</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>流程3：消息转发</strong></p>
<ul>
<li>调用forwardingTargetForSelector：方法，如果返回值不为nil，则向返回值发送消息objc_msgSend(返回值，方法)</li>
<li>如果返回值为nil，则调用methodSignatureForSelector:方法，返回值不为nil，则调用forwardInvocation:方法</li>
<li>如果返回值为nil，则调用doesNotRecognizeSelector：方法</li>
</ul>
<p>开发者可以在forwardInvocation:方法中自定义任何逻辑</p>
<p>以上方法都有对象方法、类方法2个版本（前面可以是加号+，也可以是减号-）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    // objc_msgSend([[MJCat alloc] init], @selector(test))</span><br><span class="line">    // [[[MJCat alloc] init] test]</span><br><span class="line">    if (aSelector == @selector(test)) return [[MJCat alloc] init];</span><br><span class="line"></span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">//&#123;</span><br><span class="line">//    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">//    </span><br><span class="line">//    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//+ (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;1123&quot;);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">+ (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/09/08-objc_msgSend/" data-id="cjpnsun910007cbhbrilpluxj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-06-block" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/08/06-block/" class="article-date">
  <time datetime="2018-11-08T05:12:45.969Z" itemprop="datePublished">2018-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="block"><a href="#block" class="headerlink" title="block"></a>block</h1><h4 id="block底层数据结构"><a href="#block底层数据结构" class="headerlink" title="block底层数据结构"></a>block底层数据结构</h4><ul>
<li><p>block本质上也是一个OC对象，它内部含有isa指针</p>
</li>
<li><p>block是封装了函数调用以及函数调用环境的OC对象</p>
</li>
<li><p>block底层结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 例如这样的一个block</span><br><span class="line">int age = 10;</span><br><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line">	NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 底层结构是</span><br><span class="line">// 包含三部分：block的内部实现，block的描述信息，引用(捕捉的)成员信息</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">	struct __block_impl impl; // block的内部实现信息</span><br><span class="line">    struct __main_block_desc_0 *Desc; // block的描述信息</span><br><span class="line">	int age; // 引用的属性列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// block的实现部分</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa; // isa指针</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr; // 方法地址，用例调用block封装的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// block的描述信息，注意，如果block捕捉的属性是对象信息，那这里会有block对对象的引用函数(即是强引用还是弱引用，以及如何进行内存管理)</span><br><span class="line">struc __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size; // block的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>block的类型</strong></p>
<p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>
<ul>
<li><strong>NSGlobalBlock</strong>（NSConcreteGlobalBlock）：数据区域</li>
<li><strong>NSStackBlock</strong>（NSConcreteStackBlock）：栈区</li>
<li><strong>NSMallocBlock</strong>（NSConcreteMallocBlock）：堆区</li>
</ul>
<p>应用程序的内存分配：程序区域（.text）、数据区域（.data）、堆、栈</p>
<p><strong>block类型的转变</strong>：</p>
<ul>
<li>没有访问auto变量——&gt;NSGlobalBlock</li>
<li>访问了auto变量——&gt;NSStackBlock</li>
<li>NSStackBlock调用了copy——&gt;NSMallockBlock</li>
</ul>
<p><strong>每一种block调用copy后</strong></p>
<p>| Block类型      | 副本源的配置存储域 | copy后的效果 |<br>| ————– | —————— | ———— |<br>| NSGlobalBlock  | 程序的数据区       | 什么也不做   |<br>| NSStackBlock   | 栈区               | 从栈复制到堆 |<br>| NSMallockBlock | 堆区               | 引用计数加一 |</p>
</li>
<li><p><strong>MRC下block属性建议写法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(copy, nonatomic) void(^block)(void);</span><br></pre></td></tr></table></figure>
<p>即用属性修饰词<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  因为用了```copy```会将block从栈区复制到堆区进行操作，防止获取错误信息。如果block在栈区，且引用的auto成员变量也在栈区，系统会自动销毁收回成员变量，这时候再访问就容易获取错误信息，而复制到堆上就不会，堆上的信息需要程序员自己销毁。</span><br><span class="line"></span><br><span class="line">- **ARC环境下的block:**</span><br><span class="line"></span><br><span class="line">  - 建议写法：</span><br><span class="line"></span><br><span class="line">    ```objective-c</span><br><span class="line">    // 以下两中写法都可以，但为了同步MRC，建议用copy</span><br><span class="line">    @property (strong, nonatomic) void (^block)(void);</span><br><span class="line">    @property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>编译器会根据以下情况自动将栈上的block复制到堆上</p>
<ul>
<li><p>block作为函数返回值时</p>
</li>
<li><p>将block赋值给__strong指针时，即强引用时</p>
</li>
<li><p>block作为Cocoa API中方法名含有usingBlock的方法参数时</p>
</li>
<li><p>block作为GCD API的方法参数时</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>block引用对象类型的auto变量</strong></p>
<ul>
<li><p>如果block在栈上，将不会对auto变量产生强引用</p>
</li>
<li><p>如果block被拷贝到堆上：</p>
<p>会调用block内部的copy函数，copy函数内部会调用<figure class="highlight plain"><figcaption><span>__weak __unsafe_unretained**)作出相应的操作，形成强引用或弱引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - block从堆上移除：</span><br><span class="line"></span><br><span class="line">    会调用block内部的dispose函数，dispose函数内部会调用```_Block_object_dispose```，```_Block_object_dispose```函数会自动释放引用的auto变量</span><br><span class="line"></span><br><span class="line">- **__block修饰符**</span><br><span class="line"></span><br><span class="line">  - __block可以解决block内部无法修改auto变量的问题</span><br><span class="line"></span><br><span class="line">  - __block不能修饰全局变量、静态变量（static）</span><br><span class="line"></span><br><span class="line">  - block在栈上时，并不会对__block变量产生强引用</span><br><span class="line"></span><br><span class="line">  - 内部原理：</span><br><span class="line"></span><br><span class="line">    编译器会将__block变量包装成一个对象，然后进行操作</span><br><span class="line"></span><br><span class="line">    ```objective-c</span><br><span class="line">    // 简单的block</span><br><span class="line">    __block int age = 10;</span><br><span class="line">    ^&#123;</span><br><span class="line">    	NSLog(@&quot;age is %d&quot;, age);</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    // 编译器编译后的block对象，将age包装成了__Block_byref_age_0的对象</span><br><span class="line">    struct __main_block_impl_0 &#123;</span><br><span class="line">    	struct __block_impl impl;</span><br><span class="line">        struct __main_block_desc_0 *Desc;</span><br><span class="line">        __Block_byref_age_0 *age; // by ref</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // __Block_byref_age_0：age包装后的对象</span><br><span class="line">    struct __Block_byref_age_0 &#123;</span><br><span class="line">        void *isa;</span><br><span class="line">        __Block_byref_age_0 *__forwarding; // 指向自己的指针</span><br><span class="line">        int __flags;</span><br><span class="line">        int __size;</span><br><span class="line">        int age; // 使用的值，真实值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>内部修改block变量：拿到block对象的age，找到age中的<strong>forwarding，再通过forwarding找到变量包装后的对象来修改里面的变量值：age-&gt;</strong>forwarding-&gt;age = XXX.</p>
<p><strong>注意：</strong>当block被复制到堆上时，栈上的block里面的__forwarding指针指向堆上的block对象</p>
</li>
</ul>
</li>
</ul>
<h4 id="block的循环引用"><a href="#block的循环引用" class="headerlink" title="block的循环引用"></a>block的循环引用</h4><ul>
<li><p>用__weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self)weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">	printf(&quot;%p&quot;,weakSelf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用__unsafe_unretained解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__unsafe_unretained id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">	printf(&quot;%p&quot;,weakSelf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用__block解决（必须要调用block）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">	printf(&quot;%p&quot;,weakSelf);</span><br><span class="line">    weakSelf = nil;</span><br><span class="line">&#125;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
</li>
</ul>
<p>建议用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Tips</span><br><span class="line"></span><br><span class="line">- **clang将oc转换成c\c++时，__weak问题解决**</span><br><span class="line"></span><br><span class="line">  需要支持ARC、指定运行时系统版本</span><br><span class="line"></span><br><span class="line">  ```shell</span><br><span class="line">  xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</span><br><span class="line">  # 不加对比：</span><br><span class="line">  xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/08/06-block/" data-id="cjpnsun900005cbhb2uqnv2ke" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-05-关联对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/08/05-关联对象/" class="article-date">
  <time datetime="2018-11-08T02:36:44.508Z" itemprop="datePublished">2018-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h1><h4 id="关联对象API"><a href="#关联对象API" class="headerlink" title="关联对象API"></a>关联对象API</h4><ul>
<li><p>添加关联对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, pbjc_AssociationPolicy poicy)</span><br><span class="line"></span><br><span class="line">// object 需要关联的对象</span><br><span class="line">// key 要关联的键</span><br><span class="line">// value 要关联的值</span><br><span class="line">// policy 关联政策：</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得关联对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除所有关联对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联对象的参数"><a href="#关联对象的参数" class="headerlink" title="关联对象的参数"></a>关联对象的参数</h4><ul>
<li><p><strong>object</strong>:  要关联的对象</p>
</li>
<li><p><strong>value</strong>：要关联的值</p>
</li>
<li><p><strong>policy</strong>：关联政策</p>
<ul>
<li>OBJC_ASSOCIATION_ASSIGN：对应的修饰符：assign</li>
<li>OBJC_ASSOCIATION_RETAIN_NONATOMIC：对应的修饰符 strong,nonatomic</li>
<li>OBJC_ASSOCIATION_COPY_NONATOMIC：copy,nonatomic</li>
<li>OBJC_ASSOCIATION_RETAIN: strong, atomic</li>
<li>OBJC_ASSOCIATION_COPY：copy, atomic</li>
</ul>
</li>
<li><p><strong>key</strong>：要关联的key值：</p>
<p>常见用法：</p>
<ul>
<li><p>定义一个key，并将key的内存地址赋值给key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, policy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个char类型的key，直接用这个key的内存地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void *MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, policy);</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用属性名作为key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, @&quot;property&quot;, value, policy);</span><br><span class="line">objc_getAssociatedObject(obj, @&quot;property&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用get方法的@selector作为key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, @selector(getter), value, policy);</span><br><span class="line">objc_getAssociatedObject(obj, @selector(getter));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h4><p>关联对象并不是被存储在关联对象本身的内存中</p>
<p>关联对象存储在全局的统一的一个AssociationsManager中</p>
<ul>
<li><p>实现关联对象技术的核心对象有</p>
<ul>
<li>AssociationsManager</li>
<li>AssociationsHashMap</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li><p>AssociationsManager对象中有AssociationsHashMap</p>
<figure class="highlight plain"><figcaption><span>*_map;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- AssociationsHashMap存放着所有的关联对象和其对应的ObjectAssociationMap</span><br><span class="line"></span><br><span class="line">  ```objective-c</span><br><span class="line">  // disguised_ptr_t----&gt;obj的内存地址经过位运算后的值，相当于obj</span><br><span class="line">  disguised_ptr_t: ObjectAssociationMap // 一个对象代表着这样一个键值对</span><br><span class="line">  disguised_ptr_t: ObjectAssociationMap </span><br><span class="line">  disguised_ptr_t: ObjectAssociationMap</span><br><span class="line">  ······</span><br></pre></td></tr></table></figure>
</li>
<li><p>ObjectAssociationMap存放着这个对象下面所有的关联信息（key: ObjcAssociation）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// void *-----&gt; Key</span><br><span class="line">void * : ObjcAssociation  // 对象下面的每一个属性对应着这样一个键值对</span><br><span class="line">void * : ObjcAssociation  </span><br><span class="line">void * : ObjcAssociation</span><br><span class="line">······</span><br></pre></td></tr></table></figure>
</li>
<li><p>ObjcAssociation里面存放着值（value）和关联政策（policy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t _policy; // policy</span><br><span class="line">id _value;		   // value</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/08/05-关联对象/" data-id="cjpnsun8y0003cbhbaqkdfpjz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-04-category_load_initialize" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/04-category_load_initialize/" class="article-date">
  <time datetime="2018-11-07T07:39:49.666Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Category-Load-Initialize"><a href="#Category-Load-Initialize" class="headerlink" title="Category_Load_Initialize"></a>Category_Load_Initialize</h1><h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><ul>
<li><p><strong>category实现原理</strong></p>
<ul>
<li><p>category在编译时，会被编程成结构体struct category_t，里面存储着原类名、对象方法、类方法、属性、协议信息</p>
</li>
<li><p>在程序运行的时候，runtime会将category中的数据，合并到类信息中（类对象-对象方法、属性信息、协议信息，元类对象-类方法中）</p>
</li>
<li><p>分类的执行顺序：后编译的先执行，分类方法优先于原类方法执行</p>
<ul>
<li><p>分类的方法在合并到类信息之前，会按照后编译到先编译的顺序将每个分类的方法数组先后取出</p>
</li>
<li><p>在分类方法合并到类信息中时，会将分类中的方法数组插入到类原方法数组前，即现将原方法数组后移，再讲分类方法插入到最前面</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>category与class extension的区别</strong><ul>
<li>class extension在编译的时候就已经将数据合并在类信息中了，category先放在了category——t这样的数据结构中，运行时再合并到类信息中</li>
<li>category添加的属性不会自动生成setter和getter方法的实现和成员变量，只会声明setget方法，需要通过runtime自己实现set和get方法</li>
<li>class extension 主要是为了不将私有的属性暴露在头文件中，自己内部使用</li>
</ul>
</li>
</ul>
<h4 id="load方法加载"><a href="#load方法加载" class="headerlink" title="load方法加载"></a>load方法加载</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 每个类、分类的```+load```在程序运行过程中只加载一次</span><br><span class="line">- ```+load```的调用过程，区别于普通方法以消息发送机制（objec_senMessage）调用，它是直接拿到```+load```的内存地址（从load方法数组中获取）直接调用</span><br><span class="line">- 如果手动调用```+load```方法，就同普通方法调用一样以消息发送机制进行调用</span><br><span class="line">- 调用顺序：</span><br><span class="line">  - 先调用类的```+load</span><br></pre></td></tr></table></figure>
<ul>
<li>无关联的类之间按照编译顺序调用（先编译先调用）</li>
<li>调用子类的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 再调用分类的```+load</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Initialieze"><a href="#Initialieze" class="headerlink" title="Initialieze"></a>Initialieze</h4><ul>
<li><p><code>+initialize</code>在类第一次接收到消息的时候进行调用</p>
</li>
<li><p><code>+initialize</code>调用机制是使用的消息传递机制<code>objc_sendMessage()</code>进行的</p>
</li>
<li><p>调用顺序：</p>
<ul>
<li><p>先调用父类的<code>+initialize</code>再调用子类的（在调用的时候，应用了递归遍历父类来调用初始化方法）</p>
</li>
<li><p>先初始化父类，再初始化子类，每个类只初始化一次（如果某个类没有实现初始化方法，就会用其superclass指针向上找父类的初始化方法进行调用—-消息传递机制进行调用）</p>
</li>
</ul>
</li>
</ul>
<h4 id="load与initialize的区别"><a href="#load与initialize的区别" class="headerlink" title="load与initialize的区别"></a>load与initialize的区别</h4><ul>
<li><p><strong>1、调用方式</strong></p>
<ul>
<li><p>load的调用方式是，找到load方法的内存地址， 直接进行调用</p>
</li>
<li><p>initialize的调用方式是，消息发送机制进行调用（objc_sendMessage）</p>
</li>
</ul>
</li>
<li><p><strong>2、调用时间</strong></p>
<ul>
<li><p>load是在类被加载到内存的时候进行调用</p>
</li>
<li><p>initialize是在类第一次接受到消息的时候进行调用</p>
</li>
</ul>
</li>
<li><p><strong>3、调用顺序</strong></p>
<ul>
<li>load的调用顺序是：<ul>
<li>先调用类的，在调用分类的load<ul>
<li>先编译的类，优先调用load</li>
<li>调用子类的load前会先调用父类的load(底层在调用之前会递归遍历父类进行调用)</li>
</ul>
</li>
<li>再调用分类的load<ul>
<li>分类之间，按照编译顺序进行调用，先编译的先调用（底层将load方法按照编译顺序存储在了有序数组中的）</li>
</ul>
</li>
</ul>
</li>
<li>initialize的调用顺序是：<ul>
<li>先初始化父类的，再初始化子类的</li>
<li>如果子类没有实现初始化方法，通过superclass向上寻找调用父类的</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/07/04-category_load_initialize/" data-id="cjpnsun8w0001cbhbexwly1x2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-03-KVC" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/03-KVC/" class="article-date">
  <time datetime="2018-11-07T04:24:19.589Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性.</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul>
<li><p>常见API</p>
<ul>
<li>-(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</li>
<li>-(void)setValue:(id)value forKey:(NSString *)key;</li>
<li>-(id)valueForKeyPath:(NSString *)keyPath;</li>
<li>-(id)valueForKey:(NSString *)key; </li>
</ul>
</li>
<li><p>forKey与forKeyPath的区别</p>
<ul>
<li><p>forkey：访问其直接属性</p>
</li>
<li><p>forKeyPath：访问直接属性或间接属性，可根据属性路径一层一层访问下去</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Cat : NSObject</span><br><span class="line">@property (assign, nonatomic) int weight;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (assign, nonatomic) int age;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) Cat *cat;</span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">// 这里通过kvc访问person下面的cat对象里面的weight，使用forKey是不行的，需要使用forKeyPath, forKeyPay:@&quot;cat.weight&quot;,这样一层一层路径关联下去就可以访问到</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="setVaule-forKey-原理"><a href="#setVaule-forKey-原理" class="headerlink" title="setVaule: forKey: 原理"></a>setVaule: forKey: 原理</h4><p>当调用此方法时：</p>
<ul>
<li><p>先查找<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 如果上面两个set方法都没找到，查看```accessInstanceVariablesDirectly```方法的返回值（默认是YES）</span><br><span class="line">- 如果上个步骤返回为NO，则调用```setValue:forUndefinedKey:```并抛出异常```NSUnknownKeyException</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>如果上个步骤的返回值是YES，按照<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### valueForKey:的原理</span><br><span class="line"></span><br><span class="line">当调用此方法时：</span><br><span class="line"></span><br><span class="line">- 按照```getKey、key、isKey、_key```顺序查找get方法，找到了，调用方法返回值</span><br><span class="line">- 若以上都没有找到，则调用```accessInstanceVariablesDirectly```方法，查看其返回值</span><br><span class="line">- 如果上一步返回时NO,则调用```setValue:forUndefinedKey:```并抛出异常```NSUnknownKeyException</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>如果上个步骤的返回值是YES，按照<code>_key、_isKey、key、isKey</code>的顺序查找成员变量，找到成员变量取值返回，找不到抛出异常</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/07/03-KVC/" data-id="cjpnsun8z0004cbhbna8eak7v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-02-KVO" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/02-KVO/" class="article-date">
  <time datetime="2018-11-07T02:22:07.886Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>Key-Value Observing</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>利用runtime API动态生成一个子类，并让实例对象的isa指针，从原来的类指向这个子类</li>
<li>这个子类会重写监听属性的set方法，在set方法中完成对属性修改的监听，调用监听的方法</li>
<li>这个子类的superclass属性指向其父类，方便调用不需要重写的方法，比如属性的get方法</li>
<li>实现流程：<ul>
<li>修改实例对象的属性值时，会通过isa指针找到新的子类</li>
<li>在新的子类中找到其对应的属性set方法</li>
<li>在set方法中会调用Foundation的c语言函数（_NSSetXXXValueAndNotify），这个函数会实现属性的赋值、监听器的触发<ul>
<li>_NSSetXXXValueAndNotify()函数中会调用：willChangeValueForKey:方法</li>
<li>调用父类的set方法，让其属性完成赋值</li>
<li>再调用didChangeValueForKey：方法，这个方法内部会触发监听器的监听方法</li>
</ul>
</li>
</ul>
</li>
<li>其他：<ul>
<li>会重写class方法：返回原始类，让开发者忽略子类的存在，隐藏kvo的内部实现</li>
<li>会重写delloc方法：需要在销毁时做些额外处理</li>
<li>会重新_isKVOA方法</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>手动触发KVO：手动调用willChangeValueForKey:方法，didChangeValueForKey:方法</p>
</li>
<li><p>直接修改成员变量会不会触发KVO：不会触发，因为没有调用其属性的set方法</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ikirk.cn/2018/11/07/02-KVO/" data-id="cjpnsun8x0002cbhbg2hd0di5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/本质-底层实现/">本质 底层实现</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/本质-底层实现/" style="font-size: 10px;">本质 底层实现</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/12/NSObject本质/">NSObject本质</a>
          </li>
        
          <li>
            <a href="/2018/11/30/本地数据存储/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/21/13-内存管理/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/20/设计模式与架构设计/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/20/LLVM/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Kirk<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>